
Lock_Box_5.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008c  00800100  00000860  000008f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000860  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000023  0080018c  0080018c  00000980  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000980  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000118  00000000  00000000  000009b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000e5c  00000000  00000000  00000ac8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000455  00000000  00000000  00001924  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000056d  00000000  00000000  00001d79  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000031c  00000000  00000000  000022e8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000050e  00000000  00000000  00002604  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000009b0  00000000  00000000  00002b12  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000110  00000000  00000000  000034c2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 85 00 	jmp	0x10a	; 0x10a <__ctors_end>
   4:	0c 94 b7 01 	jmp	0x36e	; 0x36e <__vector_1>
   8:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
   c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  10:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  14:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  18:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  1c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  20:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  24:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  28:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  2c:	0c 94 dc 01 	jmp	0x3b8	; 0x3b8 <__vector_11>
  30:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  34:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  38:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  3c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  40:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  44:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  48:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  4c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  50:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  54:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  58:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  5c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  60:	0c 94 a8 03 	jmp	0x750	; 0x750 <__vector_24>
  64:	0c 94 a2 00 	jmp	0x144	; 0x144 <__bad_interrupt>
  68:	c2 03       	fmuls	r20, r18
  6a:	14 04       	cpc	r1, r4
  6c:	14 04       	cpc	r1, r4
  6e:	14 04       	cpc	r1, r4
  70:	14 04       	cpc	r1, r4
  72:	14 04       	cpc	r1, r4
  74:	14 04       	cpc	r1, r4
  76:	14 04       	cpc	r1, r4
  78:	c2 03       	fmuls	r20, r18
  7a:	14 04       	cpc	r1, r4
  7c:	14 04       	cpc	r1, r4
  7e:	14 04       	cpc	r1, r4
  80:	14 04       	cpc	r1, r4
  82:	14 04       	cpc	r1, r4
  84:	14 04       	cpc	r1, r4
  86:	14 04       	cpc	r1, r4
  88:	c4 03       	fmuls	r20, r20
  8a:	14 04       	cpc	r1, r4
  8c:	14 04       	cpc	r1, r4
  8e:	14 04       	cpc	r1, r4
  90:	14 04       	cpc	r1, r4
  92:	14 04       	cpc	r1, r4
  94:	14 04       	cpc	r1, r4
  96:	14 04       	cpc	r1, r4
  98:	14 04       	cpc	r1, r4
  9a:	14 04       	cpc	r1, r4
  9c:	14 04       	cpc	r1, r4
  9e:	14 04       	cpc	r1, r4
  a0:	14 04       	cpc	r1, r4
  a2:	14 04       	cpc	r1, r4
  a4:	14 04       	cpc	r1, r4
  a6:	14 04       	cpc	r1, r4
  a8:	c4 03       	fmuls	r20, r20
  aa:	14 04       	cpc	r1, r4
  ac:	14 04       	cpc	r1, r4
  ae:	14 04       	cpc	r1, r4
  b0:	14 04       	cpc	r1, r4
  b2:	14 04       	cpc	r1, r4
  b4:	14 04       	cpc	r1, r4
  b6:	14 04       	cpc	r1, r4
  b8:	14 04       	cpc	r1, r4
  ba:	14 04       	cpc	r1, r4
  bc:	14 04       	cpc	r1, r4
  be:	14 04       	cpc	r1, r4
  c0:	14 04       	cpc	r1, r4
  c2:	14 04       	cpc	r1, r4
  c4:	14 04       	cpc	r1, r4
  c6:	14 04       	cpc	r1, r4
  c8:	10 04       	cpc	r1, r0
  ca:	14 04       	cpc	r1, r4
  cc:	14 04       	cpc	r1, r4
  ce:	14 04       	cpc	r1, r4
  d0:	14 04       	cpc	r1, r4
  d2:	14 04       	cpc	r1, r4
  d4:	14 04       	cpc	r1, r4
  d6:	14 04       	cpc	r1, r4
  d8:	ed 03       	fmulsu	r22, r21
  da:	14 04       	cpc	r1, r4
  dc:	14 04       	cpc	r1, r4
  de:	14 04       	cpc	r1, r4
  e0:	14 04       	cpc	r1, r4
  e2:	14 04       	cpc	r1, r4
  e4:	14 04       	cpc	r1, r4
  e6:	14 04       	cpc	r1, r4
  e8:	14 04       	cpc	r1, r4
  ea:	14 04       	cpc	r1, r4
  ec:	14 04       	cpc	r1, r4
  ee:	14 04       	cpc	r1, r4
  f0:	14 04       	cpc	r1, r4
  f2:	14 04       	cpc	r1, r4
  f4:	14 04       	cpc	r1, r4
  f6:	14 04       	cpc	r1, r4
  f8:	e1 03       	fmuls	r22, r17
  fa:	14 04       	cpc	r1, r4
  fc:	14 04       	cpc	r1, r4
  fe:	14 04       	cpc	r1, r4
 100:	14 04       	cpc	r1, r4
 102:	14 04       	cpc	r1, r4
 104:	14 04       	cpc	r1, r4
 106:	14 04       	cpc	r1, r4
 108:	ff 03       	fmulsu	r23, r23

0000010a <__ctors_end>:
 10a:	11 24       	eor	r1, r1
 10c:	1f be       	out	0x3f, r1	; 63
 10e:	cf ef       	ldi	r28, 0xFF	; 255
 110:	d8 e0       	ldi	r29, 0x08	; 8
 112:	de bf       	out	0x3e, r29	; 62
 114:	cd bf       	out	0x3d, r28	; 61

00000116 <__do_copy_data>:
 116:	11 e0       	ldi	r17, 0x01	; 1
 118:	a0 e0       	ldi	r26, 0x00	; 0
 11a:	b1 e0       	ldi	r27, 0x01	; 1
 11c:	e0 e6       	ldi	r30, 0x60	; 96
 11e:	f8 e0       	ldi	r31, 0x08	; 8
 120:	02 c0       	rjmp	.+4      	; 0x126 <__do_copy_data+0x10>
 122:	05 90       	lpm	r0, Z+
 124:	0d 92       	st	X+, r0
 126:	ac 38       	cpi	r26, 0x8C	; 140
 128:	b1 07       	cpc	r27, r17
 12a:	d9 f7       	brne	.-10     	; 0x122 <__do_copy_data+0xc>

0000012c <__do_clear_bss>:
 12c:	21 e0       	ldi	r18, 0x01	; 1
 12e:	ac e8       	ldi	r26, 0x8C	; 140
 130:	b1 e0       	ldi	r27, 0x01	; 1
 132:	01 c0       	rjmp	.+2      	; 0x136 <.do_clear_bss_start>

00000134 <.do_clear_bss_loop>:
 134:	1d 92       	st	X+, r1

00000136 <.do_clear_bss_start>:
 136:	af 3a       	cpi	r26, 0xAF	; 175
 138:	b2 07       	cpc	r27, r18
 13a:	e1 f7       	brne	.-8      	; 0x134 <.do_clear_bss_loop>
 13c:	0e 94 d7 02 	call	0x5ae	; 0x5ae <main>
 140:	0c 94 2e 04 	jmp	0x85c	; 0x85c <_exit>

00000144 <__bad_interrupt>:
 144:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000148 <Display_Single>:
/*******************************************************************************
*                        Display to screen  Functions 						   *
*******************************************************************************/
// this function is called to print out single characters to LCD
void Display_Single(unsigned char  *chr_msg)
{
 148:	cf 93       	push	r28
 14a:	df 93       	push	r29
 14c:	00 d0       	rcall	.+0      	; 0x14e <Display_Single+0x6>
 14e:	1f 92       	push	r1
 150:	cd b7       	in	r28, 0x3d	; 61
 152:	de b7       	in	r29, 0x3e	; 62
	unsigned char DATA_out[3];
	DATA_out[0] = i2c_addr ;		//LCD Address
 154:	28 e7       	ldi	r18, 0x78	; 120
 156:	29 83       	std	Y+1, r18	; 0x01
	DATA_out[1] = WRITE_CMD;		//Control word instruction will follow
 158:	20 e4       	ldi	r18, 0x40	; 64
 15a:	2a 83       	std	Y+2, r18	; 0x02
	DATA_out[2] = *chr_msg;			//instruction byte to be sent
 15c:	fc 01       	movw	r30, r24
 15e:	80 81       	ld	r24, Z
 160:	8b 83       	std	Y+3, r24	; 0x03
	
	
	TWI_Start_Transceiver_With_Data(DATA_out, 3);
 162:	63 e0       	ldi	r22, 0x03	; 3
 164:	ce 01       	movw	r24, r28
 166:	01 96       	adiw	r24, 0x01	; 1
 168:	0e 94 84 03 	call	0x708	; 0x708 <TWI_Start_Transceiver_With_Data>
}
 16c:	0f 90       	pop	r0
 16e:	0f 90       	pop	r0
 170:	0f 90       	pop	r0
 172:	df 91       	pop	r29
 174:	cf 91       	pop	r28
 176:	08 95       	ret

00000178 <LCD_SINGLE_MEM_WRITE>:
*                         Commands instructions								   *
*******************************************************************************/

//this function is called when an LCD command is sent
void LCD_SINGLE_MEM_WRITE (unsigned char BYTE)
{
 178:	cf 93       	push	r28
 17a:	df 93       	push	r29
 17c:	00 d0       	rcall	.+0      	; 0x17e <LCD_SINGLE_MEM_WRITE+0x6>
 17e:	1f 92       	push	r1
 180:	cd b7       	in	r28, 0x3d	; 61
 182:	de b7       	in	r29, 0x3e	; 62
	unsigned char DATA_out[3];
	DATA_out[0] = i2c_addr ;	//LCD Address
 184:	98 e7       	ldi	r25, 0x78	; 120
 186:	99 83       	std	Y+1, r25	; 0x01
	DATA_out[1] = DISP_CMD;	//Control word instruction will follow
 188:	1a 82       	std	Y+2, r1	; 0x02
	DATA_out[2] = BYTE;			//instruction byte to be sent
 18a:	8b 83       	std	Y+3, r24	; 0x03
	
	
	TWI_Start_Transceiver_With_Data(DATA_out, 3);
 18c:	63 e0       	ldi	r22, 0x03	; 3
 18e:	ce 01       	movw	r24, r28
 190:	01 96       	adiw	r24, 0x01	; 1
 192:	0e 94 84 03 	call	0x708	; 0x708 <TWI_Start_Transceiver_With_Data>
}
 196:	0f 90       	pop	r0
 198:	0f 90       	pop	r0
 19a:	0f 90       	pop	r0
 19c:	df 91       	pop	r29
 19e:	cf 91       	pop	r28
 1a0:	08 95       	ret

000001a2 <Initialize_LCD>:

//this function sends neccesary instruction to properly initialize LCD
void  Initialize_LCD()
{
 1a2:	cf 93       	push	r28
 1a4:	df 93       	push	r29
 1a6:	cd b7       	in	r28, 0x3d	; 61
 1a8:	de b7       	in	r29, 0x3e	; 62
 1aa:	2b 97       	sbiw	r28, 0x0b	; 11
 1ac:	0f b6       	in	r0, 0x3f	; 63
 1ae:	f8 94       	cli
 1b0:	de bf       	out	0x3e, r29	; 62
 1b2:	0f be       	out	0x3f, r0	; 63
 1b4:	cd bf       	out	0x3d, r28	; 61
	TWI_Master_Initialise();
 1b6:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <TWI_Master_Initialise>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1ba:	8f e9       	ldi	r24, 0x9F	; 159
 1bc:	9f e0       	ldi	r25, 0x0F	; 15
 1be:	01 97       	sbiw	r24, 0x01	; 1
 1c0:	f1 f7       	brne	.-4      	; 0x1be <Initialize_LCD+0x1c>
 1c2:	00 c0       	rjmp	.+0      	; 0x1c4 <Initialize_LCD+0x22>
 1c4:	00 00       	nop
	_delay_ms(CMD_DELAY);
	
	unsigned char  LCD_COMMANDS[11];
	
	LCD_COMMANDS[0]= i2c_addr;			// first Store the LCD address
 1c6:	88 e7       	ldi	r24, 0x78	; 120
 1c8:	89 83       	std	Y+1, r24	; 0x01
	LCD_COMMANDS[1]= DISP_CMD;			// Control word instructions will follow
 1ca:	1a 82       	std	Y+2, r1	; 0x02
	LCD_COMMANDS[2]= FUNC_SET_TBL0;
 1cc:	98 e3       	ldi	r25, 0x38	; 56
 1ce:	9b 83       	std	Y+3, r25	; 0x03
	LCD_COMMANDS[3]= FUNC_SET_TBL1;
 1d0:	99 e3       	ldi	r25, 0x39	; 57
 1d2:	9c 83       	std	Y+4, r25	; 0x04
	LCD_COMMANDS[4]=0x14;				// cursor Shift
 1d4:	94 e1       	ldi	r25, 0x14	; 20
 1d6:	9d 83       	std	Y+5, r25	; 0x05
	LCD_COMMANDS[5]=CONTRAST_CMD;		// Contrast
 1d8:	8e 83       	std	Y+6, r24	; 0x06
	LCD_COMMANDS[6]=0x5E;				// Power/icon/control
 1da:	8e e5       	ldi	r24, 0x5E	; 94
 1dc:	8f 83       	std	Y+7, r24	; 0x07
	LCD_COMMANDS[7]=0x6D;				// Set Follower
 1de:	8d e6       	ldi	r24, 0x6D	; 109
 1e0:	88 87       	std	Y+8, r24	; 0x08
	LCD_COMMANDS[8]=0x0C;				// Display on command no cursor
 1e2:	8c e0       	ldi	r24, 0x0C	; 12
 1e4:	89 87       	std	Y+9, r24	; 0x09
	LCD_COMMANDS[9]=CLEAR_DISP_CMD;		// Clear display command
 1e6:	81 e0       	ldi	r24, 0x01	; 1
 1e8:	8a 87       	std	Y+10, r24	; 0x0a
	LCD_COMMANDS[10]=0x07;				// Display on or OFF
 1ea:	87 e0       	ldi	r24, 0x07	; 7
 1ec:	8b 87       	std	Y+11, r24	; 0x0b
	
	TWI_Start_Transceiver_With_Data(LCD_COMMANDS, 9);
 1ee:	69 e0       	ldi	r22, 0x09	; 9
 1f0:	ce 01       	movw	r24, r28
 1f2:	01 96       	adiw	r24, 0x01	; 1
 1f4:	0e 94 84 03 	call	0x708	; 0x708 <TWI_Start_Transceiver_With_Data>
}
 1f8:	2b 96       	adiw	r28, 0x0b	; 11
 1fa:	0f b6       	in	r0, 0x3f	; 63
 1fc:	f8 94       	cli
 1fe:	de bf       	out	0x3e, r29	; 62
 200:	0f be       	out	0x3f, r0	; 63
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df 91       	pop	r29
 206:	cf 91       	pop	r28
 208:	08 95       	ret

0000020a <Clear_LCD>:
}

//claer contents of LCD. this also return curson to "home"
void Clear_LCD()
{
	LCD_SINGLE_MEM_WRITE (0x01);
 20a:	81 e0       	ldi	r24, 0x01	; 1
 20c:	0e 94 bc 00 	call	0x178	; 0x178 <LCD_SINGLE_MEM_WRITE>
 210:	08 95       	ret

00000212 <Home_Message>:
}

//print home message to LCD
void Home_Message()
{
 212:	0f 93       	push	r16
 214:	1f 93       	push	r17
 216:	cf 93       	push	r28
 218:	df 93       	push	r29
	int j=0;
	Clear_LCD();
 21a:	0e 94 05 01 	call	0x20a	; 0x20a <Clear_LCD>
 21e:	cc e4       	ldi	r28, 0x4C	; 76
 220:	d1 e0       	ldi	r29, 0x01	; 1
 222:	01 e6       	ldi	r16, 0x61	; 97
 224:	11 e0       	ldi	r17, 0x01	; 1
	
	for (j=0; j<sizeof(Message_Home); j++)
	{
		Display_Single(&Message_Home[j]);
 226:	ce 01       	movw	r24, r28
 228:	0e 94 a4 00 	call	0x148	; 0x148 <Display_Single>
 22c:	21 96       	adiw	r28, 0x01	; 1
void Home_Message()
{
	int j=0;
	Clear_LCD();
	
	for (j=0; j<sizeof(Message_Home); j++)
 22e:	c0 17       	cp	r28, r16
 230:	d1 07       	cpc	r29, r17
 232:	c9 f7       	brne	.-14     	; 0x226 <Home_Message+0x14>
	{
		Display_Single(&Message_Home[j]);
	}
}
 234:	df 91       	pop	r29
 236:	cf 91       	pop	r28
 238:	1f 91       	pop	r17
 23a:	0f 91       	pop	r16
 23c:	08 95       	ret

0000023e <Enter_Code_Message>:
	}
}

//print Enter code messaeg to LCD
void Enter_Code_Message()
{
 23e:	0f 93       	push	r16
 240:	1f 93       	push	r17
 242:	cf 93       	push	r28
 244:	df 93       	push	r29
	int j=0;
	Clear_LCD();
 246:	0e 94 05 01 	call	0x20a	; 0x20a <Clear_LCD>
 24a:	cc e1       	ldi	r28, 0x1C	; 28
 24c:	d1 e0       	ldi	r29, 0x01	; 1
 24e:	00 e3       	ldi	r16, 0x30	; 48
 250:	11 e0       	ldi	r17, 0x01	; 1
	
	
	for (j=0; j<sizeof(Message_Enter_Code); j++)
	{
		Display_Single(&Message_Enter_Code[j]);
 252:	ce 01       	movw	r24, r28
 254:	0e 94 a4 00 	call	0x148	; 0x148 <Display_Single>
 258:	21 96       	adiw	r28, 0x01	; 1
{
	int j=0;
	Clear_LCD();
	
	
	for (j=0; j<sizeof(Message_Enter_Code); j++)
 25a:	c0 17       	cp	r28, r16
 25c:	d1 07       	cpc	r29, r17
 25e:	c9 f7       	brne	.-14     	; 0x252 <Enter_Code_Message+0x14>
	{
		Display_Single(&Message_Enter_Code[j]);
	}
}
 260:	df 91       	pop	r29
 262:	cf 91       	pop	r28
 264:	1f 91       	pop	r17
 266:	0f 91       	pop	r16
 268:	08 95       	ret

0000026a <Move_Cursor_to>:
/*this function tell the LCD where to place the Cursor
Input: Y,X cordinates from row 1 to 2 and column 1-20
Ouput:void */
void Move_Cursor_to(int row, int column)
{
	LCD_SINGLE_MEM_WRITE (Cursor_Position[row-1][column-1]);
 26a:	01 97       	sbiw	r24, 0x01	; 1
 26c:	24 e1       	ldi	r18, 0x14	; 20
 26e:	28 9f       	mul	r18, r24
 270:	f0 01       	movw	r30, r0
 272:	29 9f       	mul	r18, r25
 274:	f0 0d       	add	r31, r0
 276:	11 24       	eor	r1, r1
 278:	6e 0f       	add	r22, r30
 27a:	7f 1f       	adc	r23, r31
 27c:	fb 01       	movw	r30, r22
 27e:	e0 5a       	subi	r30, 0xA0	; 160
 280:	fe 4f       	sbci	r31, 0xFE	; 254
 282:	80 81       	ld	r24, Z
 284:	0e 94 bc 00 	call	0x178	; 0x178 <LCD_SINGLE_MEM_WRITE>
 288:	08 95       	ret

0000028a <Unlock_Message>:
	}
}

//print unlock message to LCD
void Unlock_Message()
{
 28a:	0f 93       	push	r16
 28c:	1f 93       	push	r17
 28e:	cf 93       	push	r28
 290:	df 93       	push	r29
	int j=0;
	Clear_LCD();
 292:	0e 94 05 01 	call	0x20a	; 0x20a <Clear_LCD>
	Move_Cursor_to(1,5);
 296:	65 e0       	ldi	r22, 0x05	; 5
 298:	70 e0       	ldi	r23, 0x00	; 0
 29a:	81 e0       	ldi	r24, 0x01	; 1
 29c:	90 e0       	ldi	r25, 0x00	; 0
 29e:	0e 94 35 01 	call	0x26a	; 0x26a <Move_Cursor_to>
 2a2:	cd e3       	ldi	r28, 0x3D	; 61
 2a4:	d1 e0       	ldi	r29, 0x01	; 1
 2a6:	0c e4       	ldi	r16, 0x4C	; 76
 2a8:	11 e0       	ldi	r17, 0x01	; 1
	
	for (j=0; j<sizeof(Message_Unlock); j++)
	{
		Display_Single(&Message_Unlock[j]);
 2aa:	ce 01       	movw	r24, r28
 2ac:	0e 94 a4 00 	call	0x148	; 0x148 <Display_Single>
 2b0:	21 96       	adiw	r28, 0x01	; 1
{
	int j=0;
	Clear_LCD();
	Move_Cursor_to(1,5);
	
	for (j=0; j<sizeof(Message_Unlock); j++)
 2b2:	c0 17       	cp	r28, r16
 2b4:	d1 07       	cpc	r29, r17
 2b6:	c9 f7       	brne	.-14     	; 0x2aa <Unlock_Message+0x20>
	{
		Display_Single(&Message_Unlock[j]);
	}
}
 2b8:	df 91       	pop	r29
 2ba:	cf 91       	pop	r28
 2bc:	1f 91       	pop	r17
 2be:	0f 91       	pop	r16
 2c0:	08 95       	ret

000002c2 <Try_Again_Message>:

//print try again message to LCD
void Try_Again_Message()
{
 2c2:	0f 93       	push	r16
 2c4:	1f 93       	push	r17
 2c6:	cf 93       	push	r28
 2c8:	df 93       	push	r29
	int j=0;
	Clear_LCD();
 2ca:	0e 94 05 01 	call	0x20a	; 0x20a <Clear_LCD>
	Move_Cursor_to(1,5);
 2ce:	65 e0       	ldi	r22, 0x05	; 5
 2d0:	70 e0       	ldi	r23, 0x00	; 0
 2d2:	81 e0       	ldi	r24, 0x01	; 1
 2d4:	90 e0       	ldi	r25, 0x00	; 0
 2d6:	0e 94 35 01 	call	0x26a	; 0x26a <Move_Cursor_to>
 2da:	c0 e3       	ldi	r28, 0x30	; 48
 2dc:	d1 e0       	ldi	r29, 0x01	; 1
 2de:	0d e3       	ldi	r16, 0x3D	; 61
 2e0:	11 e0       	ldi	r17, 0x01	; 1
	
	for (j=0; j<sizeof(Message_Try_Again); j++)
	{
		Display_Single(&Message_Try_Again[j]);
 2e2:	ce 01       	movw	r24, r28
 2e4:	0e 94 a4 00 	call	0x148	; 0x148 <Display_Single>
 2e8:	21 96       	adiw	r28, 0x01	; 1
{
	int j=0;
	Clear_LCD();
	Move_Cursor_to(1,5);
	
	for (j=0; j<sizeof(Message_Try_Again); j++)
 2ea:	c0 17       	cp	r28, r16
 2ec:	d1 07       	cpc	r29, r17
 2ee:	c9 f7       	brne	.-14     	; 0x2e2 <Try_Again_Message+0x20>
	{
		Display_Single(&Message_Try_Again[j]);
	}
}
 2f0:	df 91       	pop	r29
 2f2:	cf 91       	pop	r28
 2f4:	1f 91       	pop	r17
 2f6:	0f 91       	pop	r16
 2f8:	08 95       	ret

000002fa <LEDs>:
Output: void */
/********************************************************
	NEED TO CHANGE POLARITY WHEN WE PLACED ON PCB
*******************************************************/
void LEDs (int green,int red,int blue)
{
 2fa:	cf 93       	push	r28
 2fc:	df 93       	push	r29
 2fe:	00 d0       	rcall	.+0      	; 0x300 <LEDs+0x6>
 300:	00 d0       	rcall	.+0      	; 0x302 <LEDs+0x8>
 302:	00 d0       	rcall	.+0      	; 0x304 <LEDs+0xa>
 304:	cd b7       	in	r28, 0x3d	; 61
 306:	de b7       	in	r29, 0x3e	; 62
	int LED_State[3];
	LED_State[0]=green;
 308:	9a 83       	std	Y+2, r25	; 0x02
 30a:	89 83       	std	Y+1, r24	; 0x01
	LED_State[1]=red;
 30c:	7c 83       	std	Y+4, r23	; 0x04
 30e:	6b 83       	std	Y+3, r22	; 0x03
	LED_State[2]=blue;
 310:	5e 83       	std	Y+6, r21	; 0x06
 312:	4d 83       	std	Y+5, r20	; 0x05
 314:	fe 01       	movw	r30, r28
 316:	31 96       	adiw	r30, 0x01	; 1
	int k=0;
	for (k=0;k<=2;k++)
 318:	80 e0       	ldi	r24, 0x00	; 0
 31a:	90 e0       	ldi	r25, 0x00	; 0
		{
			PORTB &= ~(1<<k);
		}
		else
		{
			PORTB |= (1<<k);
 31c:	41 e0       	ldi	r20, 0x01	; 1
 31e:	50 e0       	ldi	r21, 0x00	; 0
	LED_State[1]=red;
	LED_State[2]=blue;
	int k=0;
	for (k=0;k<=2;k++)
	{
		if (LED_State[k])
 320:	21 91       	ld	r18, Z+
 322:	31 91       	ld	r19, Z+
 324:	23 2b       	or	r18, r19
 326:	61 f0       	breq	.+24     	; 0x340 <LEDs+0x46>
		{
			PORTB &= ~(1<<k);
 328:	65 b1       	in	r22, 0x05	; 5
 32a:	9a 01       	movw	r18, r20
 32c:	08 2e       	mov	r0, r24
 32e:	02 c0       	rjmp	.+4      	; 0x334 <LEDs+0x3a>
 330:	22 0f       	add	r18, r18
 332:	33 1f       	adc	r19, r19
 334:	0a 94       	dec	r0
 336:	e2 f7       	brpl	.-8      	; 0x330 <LEDs+0x36>
 338:	20 95       	com	r18
 33a:	26 23       	and	r18, r22
 33c:	25 b9       	out	0x05, r18	; 5
 33e:	0a c0       	rjmp	.+20     	; 0x354 <LEDs+0x5a>
		}
		else
		{
			PORTB |= (1<<k);
 340:	65 b1       	in	r22, 0x05	; 5
 342:	9a 01       	movw	r18, r20
 344:	08 2e       	mov	r0, r24
 346:	02 c0       	rjmp	.+4      	; 0x34c <LEDs+0x52>
 348:	22 0f       	add	r18, r18
 34a:	33 1f       	adc	r19, r19
 34c:	0a 94       	dec	r0
 34e:	e2 f7       	brpl	.-8      	; 0x348 <LEDs+0x4e>
 350:	26 2b       	or	r18, r22
 352:	25 b9       	out	0x05, r18	; 5
	int LED_State[3];
	LED_State[0]=green;
	LED_State[1]=red;
	LED_State[2]=blue;
	int k=0;
	for (k=0;k<=2;k++)
 354:	01 96       	adiw	r24, 0x01	; 1
 356:	83 30       	cpi	r24, 0x03	; 3
 358:	91 05       	cpc	r25, r1
 35a:	11 f7       	brne	.-60     	; 0x320 <LEDs+0x26>
		else
		{
			PORTB |= (1<<k);
		}
	}
}
 35c:	26 96       	adiw	r28, 0x06	; 6
 35e:	0f b6       	in	r0, 0x3f	; 63
 360:	f8 94       	cli
 362:	de bf       	out	0x3e, r29	; 62
 364:	0f be       	out	0x3f, r0	; 63
 366:	cd bf       	out	0x3d, r28	; 61
 368:	df 91       	pop	r29
 36a:	cf 91       	pop	r28
 36c:	08 95       	ret

0000036e <__vector_1>:
to home screen also after a determined time out the program will return to home screen.
while in home screen the user must press START to begin the unlocking process. in this interrupt
function the user input will be enable and the timer interrupt will also be enabled.*/
// toggles arbitrary LED on and off for debug
ISR(INT0_vect)
{
 36e:	1f 92       	push	r1
 370:	0f 92       	push	r0
 372:	0f b6       	in	r0, 0x3f	; 63
 374:	0f 92       	push	r0
 376:	11 24       	eor	r1, r1
 378:	8f 93       	push	r24
 37a:	9f 93       	push	r25
 37c:	ef 93       	push	r30
 37e:	ff 93       	push	r31
	int k=0;
	
	EIMSK &= ~(1<<INT0); //disable interrupt on INT0
 380:	e8 98       	cbi	0x1d, 0	; 29
	TCNT1 = 0; //reset timer counter to 0
 382:	10 92 85 00 	sts	0x0085, r1
 386:	10 92 84 00 	sts	0x0084, r1
	TIFR1 |= (1<<OCF1A); //clear timer interrupt flag
 38a:	b1 9a       	sbi	0x16, 1	; 22
	
	User_Input=true; // enable User input from NES controller
 38c:	81 e0       	ldi	r24, 0x01	; 1
 38e:	80 93 92 01 	sts	0x0192, r24
 392:	88 ee       	ldi	r24, 0xE8	; 232
 394:	93 e0       	ldi	r25, 0x03	; 3
 396:	01 97       	sbiw	r24, 0x01	; 1
	
	//counter for debounce
	for (k=0;k<1000;k++);
 398:	00 97       	sbiw	r24, 0x00	; 0
 39a:	e9 f7       	brne	.-6      	; 0x396 <__vector_1+0x28>
	TIMSK1 |= 1<<OCIE1A; //enable interrupt for counter	
 39c:	ef e6       	ldi	r30, 0x6F	; 111
 39e:	f0 e0       	ldi	r31, 0x00	; 0
 3a0:	80 81       	ld	r24, Z
 3a2:	82 60       	ori	r24, 0x02	; 2
 3a4:	80 83       	st	Z, r24
}
 3a6:	ff 91       	pop	r31
 3a8:	ef 91       	pop	r30
 3aa:	9f 91       	pop	r25
 3ac:	8f 91       	pop	r24
 3ae:	0f 90       	pop	r0
 3b0:	0f be       	out	0x3f, r0	; 63
 3b2:	0f 90       	pop	r0
 3b4:	1f 90       	pop	r1
 3b6:	18 95       	reti

000003b8 <__vector_11>:
/*interrupt routine for internal counter.this will be used as our 
time out counter. after a determined time out the program will return to home screen were 
user input is disabled. to enable user input the user must press START which in turn causes
an interrupt described above*/
ISR(TIMER1_COMPA_vect)
{
 3b8:	1f 92       	push	r1
 3ba:	0f 92       	push	r0
 3bc:	0f b6       	in	r0, 0x3f	; 63
 3be:	0f 92       	push	r0
 3c0:	11 24       	eor	r1, r1
 3c2:	8f 93       	push	r24
 3c4:	ef 93       	push	r30
 3c6:	ff 93       	push	r31
	EIMSK |= (1<<INT0); //enable interrupt on INT0
 3c8:	e8 9a       	sbi	0x1d, 0	; 29
	TIMSK1 &= ~(1<<OCIE1A); // disable interrupt for counter
 3ca:	ef e6       	ldi	r30, 0x6F	; 111
 3cc:	f0 e0       	ldi	r31, 0x00	; 0
 3ce:	80 81       	ld	r24, Z
 3d0:	8d 7f       	andi	r24, 0xFD	; 253
 3d2:	80 83       	st	Z, r24
	
	//disable user input from NES controller and return to home screen 
	User_Input=false;	
 3d4:	10 92 92 01 	sts	0x0192, r1
	
	//reseting all variables
	User_Input=false;
 3d8:	10 92 92 01 	sts	0x0192, r1
	Combiantion_Match_counter=0;
 3dc:	10 92 8f 01 	sts	0x018F, r1
 3e0:	10 92 8e 01 	sts	0x018E, r1
	Input_Index=0;
 3e4:	10 92 91 01 	sts	0x0191, r1
 3e8:	10 92 90 01 	sts	0x0190, r1
	Continue_Match_Check =true;
 3ec:	81 e0       	ldi	r24, 0x01	; 1
 3ee:	80 93 00 01 	sts	0x0100, r24
}
 3f2:	ff 91       	pop	r31
 3f4:	ef 91       	pop	r30
 3f6:	8f 91       	pop	r24
 3f8:	0f 90       	pop	r0
 3fa:	0f be       	out	0x3f, r0	; 63
 3fc:	0f 90       	pop	r0
 3fe:	1f 90       	pop	r1
 400:	18 95       	reti

00000402 <Button_Press_Detected>:
/*This function takes the current state of the encoder and outputs 
the corresponding hex value to print out the user input to the LCD
Input: current state of encoder
Output: Hex value that will be sent to LCD*/
unsigned char Button_Press_Detected(unsigned char Button_Value)
{
 402:	eb e1       	ldi	r30, 0x1B	; 27
 404:	f1 e0       	ldi	r31, 0x01	; 1
 406:	a2 e1       	ldi	r26, 0x12	; 18
 408:	b1 e0       	ldi	r27, 0x01	; 1
 40a:	24 e1       	ldi	r18, 0x14	; 20
 40c:	31 e0       	ldi	r19, 0x01	; 1
	unsigned char Button_Pressed=0x00;
 40e:	40 e0       	ldi	r20, 0x00	; 0
	int i;
	/*step through all possible values of the encoder output 
	and match it to a button being pressed or not*/
	for (i=6;i>=0;i--)
	{
		if (Button_Value==Buttons[i])
 410:	92 91       	ld	r25, -Z
 412:	98 13       	cpse	r25, r24
 414:	01 c0       	rjmp	.+2      	; 0x418 <Button_Press_Detected+0x16>
		{
			/*print out the output. this output array conatains the value that
			will be printed to the LCD and be used to compare to the correct
			combination*/

			Button_Pressed = Output[i];
 416:	4c 91       	ld	r20, X
 418:	11 97       	sbiw	r26, 0x01	; 1
{
	unsigned char Button_Pressed=0x00;
	int i;
	/*step through all possible values of the encoder output 
	and match it to a button being pressed or not*/
	for (i=6;i>=0;i--)
 41a:	e2 17       	cp	r30, r18
 41c:	f3 07       	cpc	r31, r19
 41e:	c1 f7       	brne	.-16     	; 0x410 <Button_Press_Detected+0xe>

			Button_Pressed = Output[i];
		}
	}
	return Button_Pressed;
}
 420:	84 2f       	mov	r24, r20
 422:	08 95       	ret

00000424 <PollController>:
that will be sent to the LCD and to compare for 
a match of correct combination.
Input:  none
Output: Hex value that will be sent to LCD and for combination match*/
unsigned char PollController()
{
 424:	cf 93       	push	r28
		unsigned char Button_Pressed=0x00;
		Current_Read=PINC; //reading pins
 426:	c6 b1       	in	r28, 0x06	; 6
		
		/********************************
		*********************************
		masking pins that don't matter
		will need to unmask bit4 if we want to detect START being pressed*/
		Current_Read= Current_Read & 0b00000111; 
 428:	c7 70       	andi	r28, 0x07	; 7
 42a:	c0 93 95 01 	sts	0x0195, r28
		
		//this check will check the previous status of the pins for debouncing 
		if (Current_Read==Previous_Read)
 42e:	80 91 01 01 	lds	r24, 0x0101
 432:	c8 13       	cpse	r28, r24
 434:	1a c0       	rjmp	.+52     	; 0x46a <PollController+0x46>
		{
			//if the previous state equals current increase confidence level else so nothing
			Confidence_Level++;
 436:	20 91 93 01 	lds	r18, 0x0193
 43a:	30 91 94 01 	lds	r19, 0x0194
 43e:	2f 5f       	subi	r18, 0xFF	; 255
 440:	3f 4f       	sbci	r19, 0xFF	; 255
 442:	30 93 94 01 	sts	0x0194, r19
 446:	20 93 93 01 	sts	0x0193, r18
			if(Confidence_Level>200) //arbitrary confidence level
 44a:	29 3c       	cpi	r18, 0xC9	; 201
 44c:	31 05       	cpc	r19, r1
 44e:	7c f0       	brlt	.+30     	; 0x46e <PollController+0x4a>
			{
				Button_Pressed=Button_Press_Detected(Current_Read);
 450:	8c 2f       	mov	r24, r28
 452:	0e 94 01 02 	call	0x402	; 0x402 <Button_Press_Detected>
				Confidence_Level=0; //reset counter
 456:	10 92 94 01 	sts	0x0194, r1
 45a:	10 92 93 01 	sts	0x0193, r1
				
				/*this statement is to set a flag variable when a no press has been detected.
				this is useful so we can track when the user has depressed a button.*/
				if (Button_Pressed==0x00)
 45e:	81 11       	cpse	r24, r1
 460:	07 c0       	rjmp	.+14     	; 0x470 <PollController+0x4c>
				{
					No_Press_Flag = true;
 462:	91 e0       	ldi	r25, 0x01	; 1
 464:	90 93 8d 01 	sts	0x018D, r25
 468:	03 c0       	rjmp	.+6      	; 0x470 <PollController+0x4c>
a match of correct combination.
Input:  none
Output: Hex value that will be sent to LCD and for combination match*/
unsigned char PollController()
{
		unsigned char Button_Pressed=0x00;
 46a:	80 e0       	ldi	r24, 0x00	; 0
 46c:	01 c0       	rjmp	.+2      	; 0x470 <PollController+0x4c>
 46e:	80 e0       	ldi	r24, 0x00	; 0
					No_Press_Flag = true;
				}
				
			}
		}
		Previous_Read=Current_Read; //store current state	
 470:	c0 93 01 01 	sts	0x0101, r28
	
	return Button_Pressed;
}
 474:	cf 91       	pop	r28
 476:	08 95       	ret

00000478 <Check_For_Match>:

void Check_For_Match(unsigned char Button_Pressed)
{
	/*if the button that was pressed matches to the correct combination
	given the index the we will increase the "correctness counter*/
	if (Button_Pressed == Combination[Input_Index])
 478:	e0 91 90 01 	lds	r30, 0x0190
 47c:	f0 91 91 01 	lds	r31, 0x0191
 480:	ee 5f       	subi	r30, 0xFE	; 254
 482:	fe 4f       	sbci	r31, 0xFE	; 254
 484:	90 81       	ld	r25, Z
 486:	98 13       	cpse	r25, r24
 488:	0a c0       	rjmp	.+20     	; 0x49e <Check_For_Match+0x26>
	{
		Combiantion_Match_counter++; //increase correctness counter
 48a:	80 91 8e 01 	lds	r24, 0x018E
 48e:	90 91 8f 01 	lds	r25, 0x018F
 492:	01 96       	adiw	r24, 0x01	; 1
 494:	90 93 8f 01 	sts	0x018F, r25
 498:	80 93 8e 01 	sts	0x018E, r24
 49c:	08 95       	ret
	/* if the input does not match the correct combination then set the 
	continue checking variable to false. this will allow us to ignore future inputs. 
	i.e. makes no sense to check checking if one is already incorrect */
	else
	{
		Continue_Match_Check=false;
 49e:	10 92 00 01 	sts	0x0100, r1
 4a2:	08 95       	ret

000004a4 <Reset_Return_Home>:



void Reset_Return_Home()
{
	LEDs(1,1,1); //white on
 4a4:	41 e0       	ldi	r20, 0x01	; 1
 4a6:	50 e0       	ldi	r21, 0x00	; 0
 4a8:	61 e0       	ldi	r22, 0x01	; 1
 4aa:	70 e0       	ldi	r23, 0x00	; 0
 4ac:	81 e0       	ldi	r24, 0x01	; 1
 4ae:	90 e0       	ldi	r25, 0x00	; 0
 4b0:	0e 94 7d 01 	call	0x2fa	; 0x2fa <LEDs>
	//reset all variables
	User_Input=false;
 4b4:	10 92 92 01 	sts	0x0192, r1
	Combiantion_Match_counter=0;
 4b8:	10 92 8f 01 	sts	0x018F, r1
 4bc:	10 92 8e 01 	sts	0x018E, r1
	Input_Index=0;
 4c0:	10 92 91 01 	sts	0x0191, r1
 4c4:	10 92 90 01 	sts	0x0190, r1
	Continue_Match_Check =true;	
 4c8:	81 e0       	ldi	r24, 0x01	; 1
 4ca:	80 93 00 01 	sts	0x0100, r24
	EIFR |= (1<<INTF0); //clear interrupts on INT0 if they exists
 4ce:	e0 9a       	sbi	0x1c, 0	; 28
	EIMSK |= (1<<INT0); //enable interrupt on INT0
 4d0:	e8 9a       	sbi	0x1d, 0	; 29
	TCNT1 = 0; //reset timer counter to 0
 4d2:	10 92 85 00 	sts	0x0085, r1
 4d6:	10 92 84 00 	sts	0x0084, r1
	TIFR1 |= (1<<OCF1A); //clear timer interrupt flag
 4da:	b1 9a       	sbi	0x16, 1	; 22
	TIMSK1 &= ~(1<<OCIE1A); // disable interrupt for counter
 4dc:	ef e6       	ldi	r30, 0x6F	; 111
 4de:	f0 e0       	ldi	r31, 0x00	; 0
 4e0:	80 81       	ld	r24, Z
 4e2:	8d 7f       	andi	r24, 0xFD	; 253
 4e4:	80 83       	st	Z, r24
 4e6:	08 95       	ret

000004e8 <Check_Combination>:
Output:void*/
void Check_Combination()
{
	
	
	if (Combiantion_Match_counter>=10)
 4e8:	80 91 8e 01 	lds	r24, 0x018E
 4ec:	90 91 8f 01 	lds	r25, 0x018F
 4f0:	0a 97       	sbiw	r24, 0x0a	; 10
 4f2:	c4 f0       	brlt	.+48     	; 0x524 <Check_Combination+0x3c>
	{
		LEDs(1,0,0); //green on
 4f4:	40 e0       	ldi	r20, 0x00	; 0
 4f6:	50 e0       	ldi	r21, 0x00	; 0
 4f8:	60 e0       	ldi	r22, 0x00	; 0
 4fa:	70 e0       	ldi	r23, 0x00	; 0
 4fc:	81 e0       	ldi	r24, 0x01	; 1
 4fe:	90 e0       	ldi	r25, 0x00	; 0
 500:	0e 94 7d 01 	call	0x2fa	; 0x2fa <LEDs>
		Unlock_Message();
 504:	0e 94 45 01 	call	0x28a	; 0x28a <Unlock_Message>
		PORTD |= 1<<PORTD5; // open lock
 508:	5d 9a       	sbi	0x0b, 5	; 11
 50a:	2f ef       	ldi	r18, 0xFF	; 255
 50c:	82 e5       	ldi	r24, 0x52	; 82
 50e:	97 e0       	ldi	r25, 0x07	; 7
 510:	21 50       	subi	r18, 0x01	; 1
 512:	80 40       	sbci	r24, 0x00	; 0
 514:	90 40       	sbci	r25, 0x00	; 0
 516:	e1 f7       	brne	.-8      	; 0x510 <Check_Combination+0x28>
 518:	00 c0       	rjmp	.+0      	; 0x51a <Check_Combination+0x32>
 51a:	00 00       	nop
		_delay_ms(300);
		PORTD &= ~(1<<PORTD5); //lock off
 51c:	5d 98       	cbi	0x0b, 5	; 11
		Reset_Return_Home(); //function call
 51e:	0e 94 52 02 	call	0x4a4	; 0x4a4 <Reset_Return_Home>
 522:	08 95       	ret
			
	}
	else
	{
		LEDs(0,1,0); //red on
 524:	40 e0       	ldi	r20, 0x00	; 0
 526:	50 e0       	ldi	r21, 0x00	; 0
 528:	61 e0       	ldi	r22, 0x01	; 1
 52a:	70 e0       	ldi	r23, 0x00	; 0
 52c:	80 e0       	ldi	r24, 0x00	; 0
 52e:	90 e0       	ldi	r25, 0x00	; 0
 530:	0e 94 7d 01 	call	0x2fa	; 0x2fa <LEDs>
		Try_Again_Message(); //print to LCD
 534:	0e 94 61 01 	call	0x2c2	; 0x2c2 <Try_Again_Message>
 538:	2f ef       	ldi	r18, 0xFF	; 255
 53a:	82 e5       	ldi	r24, 0x52	; 82
 53c:	97 e0       	ldi	r25, 0x07	; 7
 53e:	21 50       	subi	r18, 0x01	; 1
 540:	80 40       	sbci	r24, 0x00	; 0
 542:	90 40       	sbci	r25, 0x00	; 0
 544:	e1 f7       	brne	.-8      	; 0x53e <Check_Combination+0x56>
 546:	00 c0       	rjmp	.+0      	; 0x548 <Check_Combination+0x60>
 548:	00 00       	nop
		_delay_ms(300);
		Reset_Return_Home();//funtion call
 54a:	0e 94 52 02 	call	0x4a4	; 0x4a4 <Reset_Return_Home>
 54e:	08 95       	ret

00000550 <Print_User_Input>:
/* this function prints the input from the controller to the LCD after
A successive input the previous input will be "covered" with a asterisk
Input :pointer to the user input*
Output: void*/
void Print_User_Input(unsigned char *Button_Pressed)
{
 550:	cf 93       	push	r28
 552:	df 93       	push	r29
 554:	ec 01       	movw	r28, r24
	/*lets check if this is the first input.
	this will determine where to place the asterisks*/
	if (Input_Index==0)
 556:	80 91 90 01 	lds	r24, 0x0190
 55a:	90 91 91 01 	lds	r25, 0x0191
 55e:	89 2b       	or	r24, r25
 560:	21 f4       	brne	.+8      	; 0x56a <Print_User_Input+0x1a>
	{
		Display_Single(Button_Pressed); //print to LCD
 562:	ce 01       	movw	r24, r28
 564:	0e 94 a4 00 	call	0x148	; 0x148 <Display_Single>
 568:	1f c0       	rjmp	.+62     	; 0x5a8 <Print_User_Input+0x58>
	}
	/*if not the first input. now we start to place asterisk on previous inputs*/
	else
	{
		Move_Cursor_to(2,(Input_Index*2-1)); // go back to previous input
 56a:	60 91 90 01 	lds	r22, 0x0190
 56e:	70 91 91 01 	lds	r23, 0x0191
 572:	66 0f       	add	r22, r22
 574:	77 1f       	adc	r23, r23
 576:	61 50       	subi	r22, 0x01	; 1
 578:	71 09       	sbc	r23, r1
 57a:	82 e0       	ldi	r24, 0x02	; 2
 57c:	90 e0       	ldi	r25, 0x00	; 0
 57e:	0e 94 35 01 	call	0x26a	; 0x26a <Move_Cursor_to>
		Display_Single("*");//print *
 582:	8a e8       	ldi	r24, 0x8A	; 138
 584:	91 e0       	ldi	r25, 0x01	; 1
 586:	0e 94 a4 00 	call	0x148	; 0x148 <Display_Single>
		Move_Cursor_to(2,(2*Input_Index+1)); // move forward to next space for current input
 58a:	60 91 90 01 	lds	r22, 0x0190
 58e:	70 91 91 01 	lds	r23, 0x0191
 592:	66 0f       	add	r22, r22
 594:	77 1f       	adc	r23, r23
 596:	6f 5f       	subi	r22, 0xFF	; 255
 598:	7f 4f       	sbci	r23, 0xFF	; 255
 59a:	82 e0       	ldi	r24, 0x02	; 2
 59c:	90 e0       	ldi	r25, 0x00	; 0
 59e:	0e 94 35 01 	call	0x26a	; 0x26a <Move_Cursor_to>
		Display_Single(Button_Pressed); //print current input to LCD
 5a2:	ce 01       	movw	r24, r28
 5a4:	0e 94 a4 00 	call	0x148	; 0x148 <Display_Single>
	}
 5a8:	df 91       	pop	r29
 5aa:	cf 91       	pop	r28
 5ac:	08 95       	ret

000005ae <main>:
	Continue_Match_Check =true;
}


int main(void)
{
 5ae:	cf 93       	push	r28
 5b0:	df 93       	push	r29
 5b2:	1f 92       	push	r1
 5b4:	cd b7       	in	r28, 0x3d	; 61
 5b6:	de b7       	in	r29, 0x3e	; 62
    //setting PBC0-PC3 as inputs
	DDRC &= ~((1<<DDC0)|(1<<DDC1)|(1<<DDC2)|(1<<DDC3));//all port B as inputs
 5b8:	87 b1       	in	r24, 0x07	; 7
 5ba:	80 7f       	andi	r24, 0xF0	; 240
 5bc:	87 b9       	out	0x07, r24	; 7
	PORTC |= ((1<<PORTC0)|(1<<PORTC1)|(1<<PORTC2)|(1<<PORTC3));//enable pull-ups
 5be:	88 b1       	in	r24, 0x08	; 8
 5c0:	8f 60       	ori	r24, 0x0F	; 15
 5c2:	88 b9       	out	0x08, r24	; 8
	
	DDRD |= ((1<<DDD5)|(1<<DDD4)); // setting PD5 and PD4 as output for solenoid and reset for LCD
 5c4:	8a b1       	in	r24, 0x0a	; 10
 5c6:	80 63       	ori	r24, 0x30	; 48
 5c8:	8a b9       	out	0x0a, r24	; 10
	PORTD |= (1<<PORTD4); //set high for LCD reset (reset is active low)
 5ca:	5c 9a       	sbi	0x0b, 4	; 11
	
	DDRB |= ((1<<DDB0)|(1<<DDB1)|(1<<DDB2)); //PB0-PB2 as outputs for LCD LEDs control
 5cc:	84 b1       	in	r24, 0x04	; 4
 5ce:	87 60       	ori	r24, 0x07	; 7
 5d0:	84 b9       	out	0x04, r24	; 4
	
	LEDs(1,1,1); //all on -white
 5d2:	41 e0       	ldi	r20, 0x01	; 1
 5d4:	50 e0       	ldi	r21, 0x00	; 0
 5d6:	61 e0       	ldi	r22, 0x01	; 1
 5d8:	70 e0       	ldi	r23, 0x00	; 0
 5da:	81 e0       	ldi	r24, 0x01	; 1
 5dc:	90 e0       	ldi	r25, 0x00	; 0
 5de:	0e 94 7d 01 	call	0x2fa	; 0x2fa <LEDs>

	
	
	//configuring interrupt INT0
	DDRD &= ~(1<<DDD2); //PD2 as input
 5e2:	52 98       	cbi	0x0a, 2	; 10
	PORTD |= (1<<PORTD2); //enable pull-up on PD2
 5e4:	5a 9a       	sbi	0x0b, 2	; 11
	EICRA |= (1<<ISC01); //set interrupt on INT0 falling edge
 5e6:	e9 e6       	ldi	r30, 0x69	; 105
 5e8:	f0 e0       	ldi	r31, 0x00	; 0
 5ea:	80 81       	ld	r24, Z
 5ec:	82 60       	ori	r24, 0x02	; 2
 5ee:	80 83       	st	Z, r24
	EIMSK |= (1<<INT0); //enable interrupt on INT0
 5f0:	e8 9a       	sbi	0x1d, 0	; 29
	
	//timer setup
	//set prescale-divide clock by 1024 and enable clear after match
	//so counter runs at ~1kHz.
	TCCR1B |= (1<<CS12 | 1<<CS10 | 1<<WGM12); 
 5f2:	e1 e8       	ldi	r30, 0x81	; 129
 5f4:	f0 e0       	ldi	r31, 0x00	; 0
 5f6:	80 81       	ld	r24, Z
 5f8:	8d 60       	ori	r24, 0x0D	; 13
 5fa:	80 83       	st	Z, r24
	OCR1A = 30000; // set value for counter every 1000=~ 1second
 5fc:	80 e3       	ldi	r24, 0x30	; 48
 5fe:	95 e7       	ldi	r25, 0x75	; 117
 600:	90 93 89 00 	sts	0x0089, r25
 604:	80 93 88 00 	sts	0x0088, r24
	
	sei(); //enable global interrupts
 608:	78 94       	sei
	
	
	 
	Initialize_LCD();
 60a:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <Initialize_LCD>
				a match is reached we can then move out of this while statement and disable 
				user input, and open lock*/
			Button_Pressed = PollController();
			
			//if encoder output is 0x00 means no buttons have been pressed
			if ((Button_Pressed != 0x00) & (Button_Held != Button_Pressed))
 60e:	11 e0       	ldi	r17, 0x01	; 1
	
	//main program loop
	while(1)
	{
		
		Home_Message();
 610:	0e 94 09 01 	call	0x212	; 0x212 <Home_Message>
 614:	8f e2       	ldi	r24, 0x2F	; 47
 616:	95 e7       	ldi	r25, 0x75	; 117
 618:	01 97       	sbiw	r24, 0x01	; 1
 61a:	f1 f7       	brne	.-4      	; 0x618 <main+0x6a>
 61c:	00 c0       	rjmp	.+0      	; 0x61e <main+0x70>
 61e:	00 00       	nop
 620:	64 c0       	rjmp	.+200    	; 0x6ea <main+0x13c>
		_delay_ms(15);
	
		while (User_Input)
		{
			LEDs(0,0,1); //blue LED on
 622:	41 e0       	ldi	r20, 0x01	; 1
 624:	50 e0       	ldi	r21, 0x00	; 0
 626:	60 e0       	ldi	r22, 0x00	; 0
 628:	70 e0       	ldi	r23, 0x00	; 0
 62a:	80 e0       	ldi	r24, 0x00	; 0
 62c:	90 e0       	ldi	r25, 0x00	; 0
 62e:	0e 94 7d 01 	call	0x2fa	; 0x2fa <LEDs>
			Enter_Code_Message();
 632:	0e 94 1f 01 	call	0x23e	; 0x23e <Enter_Code_Message>
			Move_Cursor_to(2,1);
 636:	61 e0       	ldi	r22, 0x01	; 1
 638:	70 e0       	ldi	r23, 0x00	; 0
 63a:	82 e0       	ldi	r24, 0x02	; 2
 63c:	90 e0       	ldi	r25, 0x00	; 0
 63e:	0e 94 35 01 	call	0x26a	; 0x26a <Move_Cursor_to>

			/*this double while loop was an easy way to just print to LCD once
			without having to worry about more variables*/
			while (User_Input)
 642:	80 91 92 01 	lds	r24, 0x0192
 646:	88 23       	and	r24, r24
 648:	09 f4       	brne	.+2      	; 0x64c <main+0x9e>
 64a:	4f c0       	rjmp	.+158    	; 0x6ea <main+0x13c>
			{
				
			
			unsigned char Button_Pressed = 0x00;
 64c:	19 82       	std	Y+1, r1	; 0x01
			/*
				in this block of code we will have to display the user input into 
				the LCD and also match the input to the predetermined combination.if 
				a match is reached we can then move out of this while statement and disable 
				user input, and open lock*/
			Button_Pressed = PollController();
 64e:	0e 94 12 02 	call	0x424	; 0x424 <PollController>
 652:	89 83       	std	Y+1, r24	; 0x01
			
			//if encoder output is 0x00 means no buttons have been pressed
			if ((Button_Pressed != 0x00) & (Button_Held != Button_Pressed))
 654:	20 91 8c 01 	lds	r18, 0x018C
 658:	91 2f       	mov	r25, r17
 65a:	82 13       	cpse	r24, r18
 65c:	01 c0       	rjmp	.+2      	; 0x660 <main+0xb2>
 65e:	90 e0       	ldi	r25, 0x00	; 0
 660:	99 23       	and	r25, r25
 662:	d1 f1       	breq	.+116    	; 0x6d8 <main+0x12a>
 664:	91 2f       	mov	r25, r17
 666:	81 11       	cpse	r24, r1
 668:	01 c0       	rjmp	.+2      	; 0x66c <main+0xbe>
 66a:	90 e0       	ldi	r25, 0x00	; 0
 66c:	99 23       	and	r25, r25
 66e:	a1 f1       	breq	.+104    	; 0x6d8 <main+0x12a>
			{
				Button_Held = Button_Pressed;
 670:	80 93 8c 01 	sts	0x018C, r24
				No_Press_Flag = false;
 674:	10 92 8d 01 	sts	0x018D, r1
				
				Print_User_Input(&Button_Pressed);
 678:	ce 01       	movw	r24, r28
 67a:	01 96       	adiw	r24, 0x01	; 1
 67c:	0e 94 a8 02 	call	0x550	; 0x550 <Print_User_Input>

				/*this if statement will only be true if the user pressed a button for the
				firsts time or if a partial match to the combination was made. this will allow us 
				to skip a matching inputs to the combination if the a wrong value was entered previously.*/
				if ((Input_Index==0) | Continue_Match_Check)
 680:	80 91 90 01 	lds	r24, 0x0190
 684:	90 91 91 01 	lds	r25, 0x0191
 688:	30 91 00 01 	lds	r19, 0x0100
 68c:	21 2f       	mov	r18, r17
 68e:	89 2b       	or	r24, r25
 690:	09 f0       	breq	.+2      	; 0x694 <main+0xe6>
 692:	20 e0       	ldi	r18, 0x00	; 0
 694:	21 11       	cpse	r18, r1
 696:	02 c0       	rjmp	.+4      	; 0x69c <main+0xee>
 698:	33 23       	and	r19, r19
 69a:	69 f0       	breq	.+26     	; 0x6b6 <main+0x108>
				{
					Check_For_Match(Button_Pressed);
 69c:	89 81       	ldd	r24, Y+1	; 0x01
 69e:	0e 94 3c 02 	call	0x478	; 0x478 <Check_For_Match>
					Input_Index++;
 6a2:	80 91 90 01 	lds	r24, 0x0190
 6a6:	90 91 91 01 	lds	r25, 0x0191
 6aa:	01 96       	adiw	r24, 0x01	; 1
 6ac:	90 93 91 01 	sts	0x0191, r25
 6b0:	80 93 90 01 	sts	0x0190, r24
 6b4:	09 c0       	rjmp	.+18     	; 0x6c8 <main+0x11a>
				/* if we get into this else we already now that the combination entered is wrong,
				so we only need to increment a counter so we can keep track of when to alert
				 the user the combination is wrong i.e. wait till all user inputs have been entered*/
				else
				{
					Input_Index++;
 6b6:	80 91 90 01 	lds	r24, 0x0190
 6ba:	90 91 91 01 	lds	r25, 0x0191
 6be:	01 96       	adiw	r24, 0x01	; 1
 6c0:	90 93 91 01 	sts	0x0191, r25
 6c4:	80 93 90 01 	sts	0x0190, r24
				}
				
				
				//if the user has pressed a button 6 times lets check if 
				//the lock needs to open or not and return to home screen
				if (Input_Index>=10)
 6c8:	80 91 90 01 	lds	r24, 0x0190
 6cc:	90 91 91 01 	lds	r25, 0x0191
 6d0:	0a 97       	sbiw	r24, 0x0a	; 10
 6d2:	14 f0       	brlt	.+4      	; 0x6d8 <main+0x12a>
				{
					Check_Combination();
 6d4:	0e 94 74 02 	call	0x4e8	; 0x4e8 <Check_Combination>
				}
				
			}
			
			
			if (No_Press_Flag)
 6d8:	80 91 8d 01 	lds	r24, 0x018D
 6dc:	81 11       	cpse	r24, r1
			{
				Button_Held = 0x00;
 6de:	10 92 8c 01 	sts	0x018C, r1
			Enter_Code_Message();
			Move_Cursor_to(2,1);

			/*this double while loop was an easy way to just print to LCD once
			without having to worry about more variables*/
			while (User_Input)
 6e2:	80 91 92 01 	lds	r24, 0x0192
 6e6:	81 11       	cpse	r24, r1
 6e8:	b1 cf       	rjmp	.-158    	; 0x64c <main+0x9e>
	{
		
		Home_Message();
		_delay_ms(15);
	
		while (User_Input)
 6ea:	80 91 92 01 	lds	r24, 0x0192
 6ee:	81 11       	cpse	r24, r1
 6f0:	98 cf       	rjmp	.-208    	; 0x622 <main+0x74>
 6f2:	8e cf       	rjmp	.-228    	; 0x610 <main+0x62>

000006f4 <TWI_Master_Initialise>:
Call this function to set up the TWI master to its initial standby state.
Remember to enable interrupts from the main application after initializing the TWI.
****************************************************************************/
void TWI_Master_Initialise(void)
{
  TWBR = TWI_TWBR;                                  // Set bit rate register (Baud rate). Defined in header file.
 6f4:	82 e0       	ldi	r24, 0x02	; 2
 6f6:	80 93 b8 00 	sts	0x00B8, r24
// TWSR = TWI_TWPS;                                  // Not used. Driver presumes prescaler to be 00.
  TWDR = 0xFF;                                      // Default content = SDA released.
 6fa:	8f ef       	ldi	r24, 0xFF	; 255
 6fc:	80 93 bb 00 	sts	0x00BB, r24
  TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
 700:	84 e0       	ldi	r24, 0x04	; 4
 702:	80 93 bc 00 	sts	0x00BC, r24
 706:	08 95       	ret

00000708 <TWI_Start_Transceiver_With_Data>:
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
 708:	ec eb       	ldi	r30, 0xBC	; 188
 70a:	f0 e0       	ldi	r31, 0x00	; 0
 70c:	20 81       	ld	r18, Z
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
  unsigned char temp;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
 70e:	20 fd       	sbrc	r18, 0
 710:	fd cf       	rjmp	.-6      	; 0x70c <TWI_Start_Transceiver_With_Data+0x4>

  TWI_msgSize = msgSize;                        // Number of data to transmit.
 712:	60 93 98 01 	sts	0x0198, r22
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
 716:	fc 01       	movw	r30, r24
 718:	20 81       	ld	r18, Z
 71a:	20 93 99 01 	sts	0x0199, r18
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
 71e:	20 fd       	sbrc	r18, 0
 720:	0e c0       	rjmp	.+28     	; 0x73e <TWI_Start_Transceiver_With_Data+0x36>
  {
    for ( temp = 1; temp < msgSize; temp++ )
 722:	62 30       	cpi	r22, 0x02	; 2
 724:	60 f0       	brcs	.+24     	; 0x73e <TWI_Start_Transceiver_With_Data+0x36>
 726:	31 96       	adiw	r30, 0x01	; 1
 728:	aa e9       	ldi	r26, 0x9A	; 154
 72a:	b1 e0       	ldi	r27, 0x01	; 1
 72c:	02 96       	adiw	r24, 0x02	; 2
 72e:	62 50       	subi	r22, 0x02	; 2
 730:	86 0f       	add	r24, r22
 732:	91 1d       	adc	r25, r1
      TWI_buf[ temp ] = msg[ temp ];
 734:	21 91       	ld	r18, Z+
 736:	2d 93       	st	X+, r18

  TWI_msgSize = msgSize;                        // Number of data to transmit.
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
  {
    for ( temp = 1; temp < msgSize; temp++ )
 738:	e8 17       	cp	r30, r24
 73a:	f9 07       	cpc	r31, r25
 73c:	d9 f7       	brne	.-10     	; 0x734 <TWI_Start_Transceiver_With_Data+0x2c>
      TWI_buf[ temp ] = msg[ temp ];
  }
  TWI_statusReg.all = 0;      
 73e:	10 92 97 01 	sts	0x0197, r1
  TWI_state         = TWI_NO_STATE ;
 742:	88 ef       	ldi	r24, 0xF8	; 248
 744:	80 93 89 01 	sts	0x0189, r24
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
 748:	85 ea       	ldi	r24, 0xA5	; 165
 74a:	80 93 bc 00 	sts	0x00BC, r24
 74e:	08 95       	ret

00000750 <__vector_24>:
application.
****************************************************************************/

//__interrupt__void TWI_ISR( ) 
ISR(TWI_vect)
{
 750:	1f 92       	push	r1
 752:	0f 92       	push	r0
 754:	0f b6       	in	r0, 0x3f	; 63
 756:	0f 92       	push	r0
 758:	11 24       	eor	r1, r1
 75a:	2f 93       	push	r18
 75c:	3f 93       	push	r19
 75e:	8f 93       	push	r24
 760:	9f 93       	push	r25
 762:	af 93       	push	r26
 764:	bf 93       	push	r27
 766:	ef 93       	push	r30
 768:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
 76a:	80 91 b9 00 	lds	r24, 0x00B9
 76e:	90 e0       	ldi	r25, 0x00	; 0
 770:	fc 01       	movw	r30, r24
 772:	38 97       	sbiw	r30, 0x08	; 8
 774:	e1 35       	cpi	r30, 0x51	; 81
 776:	f1 05       	cpc	r31, r1
 778:	08 f0       	brcs	.+2      	; 0x77c <__vector_24+0x2c>
 77a:	56 c0       	rjmp	.+172    	; 0x828 <__vector_24+0xd8>
 77c:	ec 5c       	subi	r30, 0xCC	; 204
 77e:	ff 4f       	sbci	r31, 0xFF	; 255
 780:	0c 94 28 04 	jmp	0x850	; 0x850 <__tablejump2__>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
 784:	10 92 96 01 	sts	0x0196, r1
    case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
 788:	e0 91 96 01 	lds	r30, 0x0196
 78c:	80 91 98 01 	lds	r24, 0x0198
 790:	e8 17       	cp	r30, r24
 792:	70 f4       	brcc	.+28     	; 0x7b0 <__vector_24+0x60>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
 794:	81 e0       	ldi	r24, 0x01	; 1
 796:	8e 0f       	add	r24, r30
 798:	80 93 96 01 	sts	0x0196, r24
 79c:	f0 e0       	ldi	r31, 0x00	; 0
 79e:	e7 56       	subi	r30, 0x67	; 103
 7a0:	fe 4f       	sbci	r31, 0xFE	; 254
 7a2:	80 81       	ld	r24, Z
 7a4:	80 93 bb 00 	sts	0x00BB, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 7a8:	85 e8       	ldi	r24, 0x85	; 133
 7aa:	80 93 bc 00 	sts	0x00BC, r24
 7ae:	43 c0       	rjmp	.+134    	; 0x836 <__vector_24+0xe6>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
 7b0:	80 91 97 01 	lds	r24, 0x0197
 7b4:	81 60       	ori	r24, 0x01	; 1
 7b6:	80 93 97 01 	sts	0x0197, r24
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 7ba:	84 e9       	ldi	r24, 0x94	; 148
 7bc:	80 93 bc 00 	sts	0x00BC, r24
 7c0:	3a c0       	rjmp	.+116    	; 0x836 <__vector_24+0xe6>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
 7c2:	e0 91 96 01 	lds	r30, 0x0196
 7c6:	81 e0       	ldi	r24, 0x01	; 1
 7c8:	8e 0f       	add	r24, r30
 7ca:	80 93 96 01 	sts	0x0196, r24
 7ce:	80 91 bb 00 	lds	r24, 0x00BB
 7d2:	f0 e0       	ldi	r31, 0x00	; 0
 7d4:	e7 56       	subi	r30, 0x67	; 103
 7d6:	fe 4f       	sbci	r31, 0xFE	; 254
 7d8:	80 83       	st	Z, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
 7da:	20 91 96 01 	lds	r18, 0x0196
 7de:	30 e0       	ldi	r19, 0x00	; 0
 7e0:	80 91 98 01 	lds	r24, 0x0198
 7e4:	90 e0       	ldi	r25, 0x00	; 0
 7e6:	01 97       	sbiw	r24, 0x01	; 1
 7e8:	28 17       	cp	r18, r24
 7ea:	39 07       	cpc	r19, r25
 7ec:	24 f4       	brge	.+8      	; 0x7f6 <__vector_24+0xa6>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 7ee:	85 ec       	ldi	r24, 0xC5	; 197
 7f0:	80 93 bc 00 	sts	0x00BC, r24
 7f4:	20 c0       	rjmp	.+64     	; 0x836 <__vector_24+0xe6>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 7f6:	85 e8       	ldi	r24, 0x85	; 133
 7f8:	80 93 bc 00 	sts	0x00BC, r24
 7fc:	1c c0       	rjmp	.+56     	; 0x836 <__vector_24+0xe6>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
      TWI_buf[TWI_bufPtr] = TWDR;
 7fe:	80 91 bb 00 	lds	r24, 0x00BB
 802:	e0 91 96 01 	lds	r30, 0x0196
 806:	f0 e0       	ldi	r31, 0x00	; 0
 808:	e7 56       	subi	r30, 0x67	; 103
 80a:	fe 4f       	sbci	r31, 0xFE	; 254
 80c:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
 80e:	80 91 97 01 	lds	r24, 0x0197
 812:	81 60       	ori	r24, 0x01	; 1
 814:	80 93 97 01 	sts	0x0197, r24
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 818:	84 e9       	ldi	r24, 0x94	; 148
 81a:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
 81e:	0b c0       	rjmp	.+22     	; 0x836 <__vector_24+0xe6>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 820:	85 ea       	ldi	r24, 0xA5	; 165
 822:	80 93 bc 00 	sts	0x00BC, r24
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
 826:	07 c0       	rjmp	.+14     	; 0x836 <__vector_24+0xe6>
    case TWI_MRX_ADR_NACK:      // SLA+R has been tramsmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been tramsmitted and NACK received
//    case TWI_NO_STATE              // No relevant state information available; TWINT = 0
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
 828:	80 91 b9 00 	lds	r24, 0x00B9
 82c:	80 93 89 01 	sts	0x0189, r24
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
 830:	84 e0       	ldi	r24, 0x04	; 4
 832:	80 93 bc 00 	sts	0x00BC, r24
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
 836:	ff 91       	pop	r31
 838:	ef 91       	pop	r30
 83a:	bf 91       	pop	r27
 83c:	af 91       	pop	r26
 83e:	9f 91       	pop	r25
 840:	8f 91       	pop	r24
 842:	3f 91       	pop	r19
 844:	2f 91       	pop	r18
 846:	0f 90       	pop	r0
 848:	0f be       	out	0x3f, r0	; 63
 84a:	0f 90       	pop	r0
 84c:	1f 90       	pop	r1
 84e:	18 95       	reti

00000850 <__tablejump2__>:
 850:	ee 0f       	add	r30, r30
 852:	ff 1f       	adc	r31, r31

00000854 <__tablejump__>:
 854:	05 90       	lpm	r0, Z+
 856:	f4 91       	lpm	r31, Z
 858:	e0 2d       	mov	r30, r0
 85a:	09 94       	ijmp

0000085c <_exit>:
 85c:	f8 94       	cli

0000085e <__stop_program>:
 85e:	ff cf       	rjmp	.-2      	; 0x85e <__stop_program>
